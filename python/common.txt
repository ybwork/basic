Гордость питонистов.

    a, b = b, a - меняет местами значения двух переменных

Общее.

    Python - интерпретируемый язык программирования.

    Это язык с динамической типизацией. То есть не надо заранее объявлять тип переменной.

    Python объектно-ориентированного программирования. При этом его реализация в python является одной из самых понятных.

Синтаксис.

    Конец строки является концом инструкции.

    Вложенные инструкции объединяются в блоки. Используйте 4 пробела.

    Иногда возможно записать несколько инструкций в одной строке, разделяя их точкой с запятой. a = 1; b = 2; print(a, b)

    Допустимо записывать одну инструкцию в нескольких строках: if (a == 1 and b == 2 and
                                                                   c == 3 and d == 4):

    Тело составной инструкции может располагаться в той же строке, что и тело основной: if x > y: print(x)

Условная инструкция.

    Конструкция с несколькими elif может также служить отличной заменой конструкции switch - case в других языках программирования.

    Числа, равные 0, пустые объекты и значение None - ложь. При этом отрицательные числа - истина.

    x = 1
    a = y if x else z

Цикл while.

    Медленный.

Цикл for.

    Быстрее чем while.

    Проходится по любому итерируемому объекту. (строки, списки, словари, множества)

Оператор continue.

    Начинает следующий проход цикла, минуя оставшееся тело цикла.

Оператор break.

    Досрочно прерывает цикл.

Else для циклов.

    Блок инструкций внутри else выполнится только в том случае, если выход из цикла произошел без помощи break.

    for i in data:
        if i == 0:
            break
    else:
        print('all rigth')

Числа.

    Бывают целые, вещественные (float), комплексные.

    int() - функция, которая преобразовывает к целому числу.

    float.is_integer() - проверяет является ли число целым.

    Вещественные числа неточны, поэтому лучше использовать Decimal и Fraction.

    Модуль math, random.

    Также для работы с комплексными числами используется также модуль cmath.

Строки.

    Строки в апострофах и в кавычках - одно и то же. Причина наличия двух вариантов в том, чтобы позволить вставлять в литералы строк символы кавычек или апострофов, не используя экранирование.

    Если перед открывающей кавычкой стоит символ 'r' (в любом регистре), то механизм экранирования отключается. a = r'C:\newt.txt'. Это ещё называют сырой строкой.

    a = 'one'; b = 'two'; a + b - конкатенация

    len(a) - длинна строки

    a[3:5] - срез строки

    При вызове методов необходимо помнить, что строки в Python относятся к категории неизменяемых последовательностей, то есть все функции и методы могут лишь создавать новую строку.

    Методы:

        a.split(',') - разбивает строку по разделителю

        a.upper() - преобразует строку к верхнему регистру

        a.lower() - преобразует строку к нижнему регистру

        a.strip() - удаление пробелов в начале и в конце строки

        'Hello {}!'.format('world') - подставляет значения в строку

Экранированные последовательности.

    \n - перевод строки

    \r - возврат каретки

Списки (list).
    
    Это упорядоченная коллекция изменяемые объектов произвольных типов.

    list('five') - функция преобразует входное значение в список

    s = [1, 'new', [3]] - создаёт список со значениями

    c = [c * 3 for c in 'list'] - наполняет список значениями

    Методы:

        list.append(x) - добавляет элемент в конец списка

        list.extend(x) - Расширяет список list, добавляя в конец все элементы списка x

        list.insert(n, x) - вставляет на i-ый элемент значение x

        list.pop([n]) - ндаляет i-ый элемент и возвращает его

Индексы.

    В Python также поддерживаются отрицательные индексы, при этом нумерация идёт с конца. a[-1]

Срезы.

    item[START:STOP:STEP] - берёт срез от номера START, до STOP (не включая его), с шагом STEP.

    a = [1, 3, 8, 7]
    a[1:]

    del a[:-3]

Кортежи (tuple).

    Это неизменяемый список.

    Имеет меньший размер в сравнении со списками.

    a = (1, 2, 3, 4, 5, 6)

    Можно испльзовать кортеж в качестве ключей словаря. d = {(1, 1, 1) : 1}

    a = tuple() - создаёт пустой кортеж

    a = () - тоже создаёт пустой кортеж

    a = ('s', ) - если не поставить запятую, то кортеж не создастся, потому что круглые скобки ничего не значат и интерпретатор воспримет одно значение, как строку.

    Все методы списков, которые не изменяют его можно использовать с кортежами: count, index и т.д.

Словари (dict).

    Это неупорядочные коллекции произвольных объектов с доступом по ключу.
    
    Их иногда ещё называют ассоциативными массивами или хеш-таблицами.

    d = {} - создание пустого словаря

    d = {'dict': 1, 'dictionary': 2}

    d = dict(short='dict', long='dictionary')

    d = dict.fromkeys(['a', 'b'], 100) выведет: {'a': 100, 'b': 100}

    d = {a: a ** 2 for a in range(7)}

    Методы:

        dict.clear() - очищает словарь.

        dict.copy() - возвращает копию словаря.

        dict.get(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а возвращает default (по умолчанию None).

        dict.update([other]) - обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются. Возвращает None (не новый словарь!).

Множества (set и frozenset).

    Это контейнер, содержащий не повторяющиеся элементы в случайном порядке.

    a = set()

    a = {i ** 2 for i in range(10)}

    Единственное отличие set от frozenset заключается в том, что set - изменяемый тип данных, а frozenset - нет.

Функции.

    Функция в python - объект, принимающий аргументы и возвращающий значение.

    Аргументы могут быть по умолчанию. Должны находиться правее обязательных.

    Функция может и не заканчиваться инструкцией return, при этом функция вернет значение None.

    Функция также может принимать переменное количество позиционных аргументов. def get(*args):

    Функция также может принимать переменное количество именнованых аргументов. def get(**kwargs):

    Именованные аргументы должны идти позже чем порядковые.

Анонимные функции, инструкция lambda.

    Выполняются быстрее обычных.

    Могут содержать лишь одно выражение.

    Создаются с помощью инструкции lambda.

    func = lambda x, y: x + y

Исключения.

    Тип данных, сообщающий программисту об ошибках.

    BaseException - базовое исключение, от которого берут начало все остальные.

    try:
        name = get_name()
    except ZeroDivisionError:
        print('error')
    else:
        print('all rigth')
    finally:
        f.close()

    В блоке try мы выполняем инструкцию, которая может породить исключение, а в блоке except мы перехватываем их.

    Инструкция else выполняется в том случае, если исключения не было.

    Finally выполняет блок инструкций в любом случае, было ли исключение, или нет (применима, когда нужно непременно что-то сделать, к примеру, закрыть файл).

Декоратор.

    Это функция, которая получает на вход другую функцию и добавляет к её поведению своё. По сути на основе одной фукнции создаёт другую. 

    def function_to_decorate():
        return 'Действие оригинальной функции'

    def my_decorator(function_to_decorate):
        def original_function():
            print("Я - код, который отработает до вызова функции")

            function_to_decorate()

            print("А я - код, срабатывающий после")

        return original_function

    def my_decorator(function_to_decorate) - чтобы передать функцию в декоратор можно написать так:

            @my_decorator
            def function_to_decorate():

            или так:

            @my_decorator1
            @my_decorator2
            def function_to_decorate(): - декораторы будут применяться по очереди к результату предыдущего

Итерируемые.

    Итерируемые - это набор объектов, которые можно по очереди вытаскивать, но нельзя посчитать длинну и взять элементы по индексу.

    Список, строка, кортеж, словарь, файл.

Итераторы.

    Итератор - это объект, который позволяет двигаться по итерируемым и получать очередной элемент.

    Если мы хотим получить все элементы итерируемого, то мы создаем итератор и вызываем у него функцию next пока не закончятся элементы.

    Когда элементы заканчиваются выбрасывается исключение StopIteration.

    Итератор должен быть итерируемым и возвращать самого себя чтобы его можно было использовать с for.

    Функции для работы с итераторами: map(), filter(), reduce(), enumerate()

    map(func, [1, 2, 3]) - берёт какую то функцию и применяет для каждого итерируемого; возвращает новый объект; не рекомендуется использовать функцию map вместе с Лямбда, лучше использовать например списковое выражение [x * 2 for x in range(5)]

    filter() - возвращает новый, отфильтрованный по какому то параметру набор данных.

    reduce() - применяет переданную функцию сначала к первым двум элементам, потом к результату первых двух элементов и третьему, потом к резльтату первых двух, третьего и четвёртого элемета и т.д.

    enumerate(['a', 'b', 'c']) - нумерует каждое итерируемое и возращает новый, пронумерованный объект.

ООП.

    Объектно-ориентированное программирование (ООП) — парадигма программирования, в которой основными концепциями являются понятия объектов и классов.

    Класс - это модель какой то сущности.

    Объект — это экземпляр класса.

    def __init__(self): - это конструктор класса. Он срабатывает автоматически при создании объекта.

    Инкапсуляция. Это механизм ограничения методов или свойств объекта.

        Инкапсуляция в Python работает лишь на уровне соглашения между программистами о том, какие атрибуты являются общедоступными, а какие — внутренними.

        class A:
            def __private(self): - это сообщает другим программистам, что функция недоступна снаружи, то есть приватная.

    Наследование. Это свойство системы, позволяющее описать новый класс на основе уже существующего и взять у него частично или полностью функциональность.

        class B(A):

    Полиморфизм. Полиморфизм - разное поведение одного и того же метода в разных классах.

    В питоне атрибуты класса не указываются заранее, а создаются в методах. Для того чтобы получить доступ к этим атрибутам из класса наследника нужно воспользоваться методом super() в классе наследнике, вызвав метод класса родителя в котором создаются атрибуты. Обычно это делается в конструкторе, но можно и в других местах.

    Философия классов: сначала описываем действия: утка крякает, летает, ест. Это называется неявная или утиная типизация. То есть это типизация, где нам важно, что делает объект, а не что хранит.








